<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>Synchronous Finite automata framework. Design.</title><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"><meta name="description" content="This document collects use-cases and software requirements for synchronous distributed finite automata framework."><style type="text/css">
body { background-image: url('http://docbook.sourceforge.net/release/images/draft.png');
       background-repeat: no-repeat;
       background-position: top left;
       /* The following properties make the watermark "fixed" on the page. */
       /* I think that's just a bit too distracting for the reader... */
       /* background-attachment: fixed; */
       /* background-position: center center; */
     }</style><link rel="home" href="#id2933221" title="Synchronous Finite automata framework. Design."><link rel="next" href="#id2945317" title="General"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="article" title="Synchronous Finite automata framework. Design."><div class="titlepage"><div><div><h2 class="title"><a name="id2933221"></a>Synchronous Finite automata framework. Design.</h2></div><div><div class="author"><h3 class="author"><span class="firstname">Yuri</span> <span class="surname">Borisov</span></h3><code class="email">&lt;<a class="email" href="mailto:yuri.borisov.v@gmail.com">yuri.borisov.v@gmail.com</a>&gt;</code></div></div><div><p class="releaseinfo">Ver.0.04 at 01-Mar-2011</p></div><div><div class="revhistory"><table border="1" width="100%" summary="Revision history"><tr><th align="left" valign="top" colspan="3"><b>Revision History</b></th></tr><tr><td align="left">Revision 0.01</td><td align="left">11-Sep-2010</td><td align="left">Yuri Borisov</td></tr><tr><td align="left" colspan="3">Initial version</td></tr><tr><td align="left">Revision 0.02</td><td align="left">22-Dec-2010</td><td align="left">Yuri Borisov</td></tr><tr><td align="left" colspan="3">Added <a class="xref" href="#sec_conn" title="Refs, Connections">the section called &#8220;Refs, Connections&#8221;</a>, <a class="xref" href="#sec_ifaces" title="Interfaces of state and object">the section called &#8220;Interfaces of state and object&#8221;</a></td></tr><tr><td align="left">Revision 0.03</td><td align="left">03-Feb-2011</td><td align="left">Yuri Borisov</td></tr><tr><td align="left" colspan="3">Added <a class="xref" href="#sec_obj_as_state" title="Controlling of the systems">the section called &#8220;Controlling of the systems&#8221;</a></td></tr><tr><td align="left">Revision 0.04</td><td align="left">01-Mar-2011</td><td align="left">Yuri Borisov</td></tr><tr><td align="left" colspan="3">Added <a class="xref" href="#uc_conn_06" title="UC_CONN_06 Actor changes extention by dis-extendig from currently attached connection point and extending to the new connection point.">the section called &#8220;UC_CONN_06 Actor changes extention by dis-extendig from currently attached connection point and 
		extending to the new connection point.&#8221;</a>, updated <a class="xref" href="#uc_conn_02" title="UC_CONN_02 Object has its own input that represent input of some internal state">the section called &#8220;UC_CONN_02 Object has its own input that represent input of some internal state&#8221;</a></td></tr></table></div></div><div><div class="abstract" title="Abstract"><p class="title"><b>Abstract</b></p><p>This document collects use-cases and software requirements for synchronous distributed finite automata framework.</p></div></div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#id2945317">General</a></span></dt><dd><dl><dt><span class="sect2"><a href="#id2950377">Introduction</a></span></dt></dl></dd><dt><span class="sect1"><a href="#sec_conn">Refs, Connections</a></span></dt><dd><dl><dt><span class="sect2"><a href="#id2955876">Introduction</a></span></dt><dt><span class="sect2"><a href="#id2948757">Use cases</a></span></dt><dt><span class="sect2"><a href="#sec_conn_objconn">How to implement object connections: just representative?</a></span></dt><dt><span class="sect2"><a href="#sec_conn_contr">The control of subsystem structure</a></span></dt></dl></dd><dt><span class="sect1"><a href="#sec_obj_as_state">Controlling of the systems</a></span></dt><dd><dl><dt><span class="sect2"><a href="#sec_obj_as_state_intro">Introduction</a></span></dt><dt><span class="sect2"><a href="#sec_obj_as_state_intro_solution">Migration to solution</a></span></dt><dt><span class="sect2"><a href="#id2952039">Two approaches for chromo change: direct change and mutation</a></span></dt><dt><span class="sect2"><a href="#sec_obj_as_state_ucs">Use cases</a></span></dt><dt><span class="sect2"><a href="#sec_obj_as_state_mutspec">Mutation spec</a></span></dt><dt><span class="sect2"><a href="#sec_obj_as_state_issues">Questions, issues</a></span></dt></dl></dd><dt><span class="sect1"><a href="#sec_ifaces">Interfaces of state and object</a></span></dt></dl></div><div class="bibliolist" title="References"><p class="title"><b>References</b></p></div><div class="sect1" title="General"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2945317"></a>General</h2></div></div></div><div class="sect2" title="Introduction"><div class="titlepage"><div><div><h3 class="title"><a name="id2950377"></a>Introduction</h3></div></div></div><p>Finite automata programming environment (FAP) is a service library that provides a client program with means 
		of implementing functionality using finite automata paradigm.
	    </p></div></div><div class="sect1" title="Refs, Connections"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec_conn"></a>Refs, Connections</h2></div></div></div><div class="sect2" title="Introduction"><div class="titlepage"><div><div><h3 class="title"><a name="id2955876"></a>Introduction</h3></div></div></div><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">Each FAP element can offer series of interfaces (thru ifaces or proxies)</li><li class="listitem">The term "Connection" means here the established ref to some interface of some FAP Element. 
		    For instance state's input is ref to "Data" interface of another state ("Data" interface allows get the data from the state)</li><li class="listitem">There can be not established ref, i.e state input that is not set </li><li class="listitem">There can be source and dest refs. Source ref is the established ref that can be used to be copied to another ref.
		    Dest ref is the ref that has to be set.</li><li class="listitem">The refs can be combined, for instance state's input can be represented by a couple of refs - 
		    Source ref to state's "Activation" iface (that can be used to set the state as active), and Dest ref that has to be set with ref to Data
		    iface of another state. Let's call this set of refs as refs socket
		    <img src="fig_refs_conns_1.png"></li><li class="listitem">The sockets can be compatible as illustrated on the figure above. In this case they can be "connected" - the dest refs set up with
		    corresponding src ref.</li><li class="listitem">It should be possible not only to connect two connection point but also to "extend" the connection point
		    (ref <a class="xref" href="#uc_conn_02" title="UC_CONN_02 Object has its own input that represent input of some internal state">the section called &#8220;UC_CONN_02 Object has its own input that represent input of some internal state&#8221;</a> for usecase). This leads to some changes to the approach shown above. First, the connection
		    by copying src to dest doesn't work here. Let's consider the situation: object "A" contains the state "A_s1" with the input "A_s1_i1".
		    Object in turn has it's own input "A_i1" that is "connected" to "A_s1_i1". But what is this "connection". We cannot set up dest on "A_s1_i1"
		    because the src on "A_i1" is not set yet.
		    <p class="simpara">So it would be more correct if we use dest as indirect ref to source instead of direct one.</p></li></ul></div></div><div class="sect2" title="Use cases"><div class="titlepage"><div><div><h3 class="title"><a name="id2948757"></a>Use cases</h3></div></div></div><div class="sect3" title="UC_CONN_01 State inputs with date type checking"><div class="titlepage"><div><div><h4 class="title"><a name="id2935695"></a>UC_CONN_01 State inputs with date type checking</h4></div></div></div>
		The dest refs with type "Data" allows client to understand what data type is accepted by the ref.  
	    </div><div class="sect3" title="UC_CONN_02 Object has its own input that represent input of some internal state"><div class="titlepage"><div><div><h4 class="title"><a name="uc_conn_02"></a>UC_CONN_02 Object has its own input that represent input of some internal state</h4></div></div></div><p> It allows to has the unified interface for states and objects. Morover it solves the problem with access to the object.
		    All access to the object shall be done via objects connection point.  </p><p>Let's use term "extention" for that. So system connection point is actually an extender. It extends the internal
		connection point</p></div><div class="sect3" title="UC_CONN_03 Connection point can be connected to many connection points"><div class="titlepage"><div><div><h4 class="title"><a name="uc_conn_03"></a>UC_CONN_03 Connection point can be connected to many connection points</h4></div></div></div><p>An example is state output that can be connected to many state inputs. The alternative way could be to have many 
		    connection points for output</p></div><div class="sect3" title="UC_CONN_04 States connection change involves state activation"><div class="titlepage"><div><div><h4 class="title"><a name="uc_conn_04"></a>UC_CONN_04 States connection change involves state activation</h4></div></div></div></div><div class="sect3" title="UC_CONN_05 Subsystem connections set can be state of system."><div class="titlepage"><div><div><h4 class="title"><a name="uc_conn_05"></a>UC_CONN_05 Subsystem connections set can be state of system.</h4></div></div></div><p>System controls the structure of subsystem (connections set, transition function). The structure
		    is represented as state - it can be connected to other states, thus the change of structure will cause the activation
		    of dependent states</p></div><div class="sect3" title="UC_CONN_06 Actor changes extention by dis-extendig from currently attached connection point and extending to the new connection point."><div class="titlepage"><div><div><h4 class="title"><a name="uc_conn_06"></a>UC_CONN_06 Actor changes extention by dis-extendig from currently attached connection point and 
		extending to the new connection point.</h4></div></div></div><p>Seems there is problem here currently because when we move extention we need to disconnect current connection point and
		connect new one. But we cannot connect new one because we don't have references to the pair connection point. We have just references to sources
		(via destinations in currnet connection point) but not to connection point itself.</p></div></div><div class="sect2" title="How to implement object connections: just representative?"><div class="titlepage"><div><div><h3 class="title"><a name="sec_conn_objconn"></a>How to implement object connections: just representative?</h3></div></div></div><p>There are at least two options of implementation:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">Object conn point is only "representation" of corresponding states conn point.
		    In this case objects conn point uses for connect the represented states conn point.</li><li class="listitem">Object conn point is true connection point</li></ul></div></div><div class="sect2" title="The control of subsystem structure"><div class="titlepage"><div><div><h3 class="title"><a name="sec_conn_contr"></a>The control of subsystem structure</h3></div></div></div><p>There is usecase - <a class="xref" href="#uc_conn_05" title="UC_CONN_05 Subsystem connections set can be state of system.">the section called &#8220;UC_CONN_05 Subsystem connections set can be state of system.&#8221;</a></p><p>This is like meta system - the system that controls the structure of other systems. But do we need to 
		have the direct representation of the structure as data? The alternative way could be having access to subsystem interface
		that allows metasystem change the connections</p></div></div><div class="sect1" title="Controlling of the systems"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec_obj_as_state"></a>Controlling of the systems</h2></div></div></div><div class="sect2" title="Introduction"><div class="titlepage"><div><div><h3 class="title"><a name="sec_obj_as_state_intro"></a>Introduction</h3></div></div></div><p>The transition function of system can depends on system time, i.e. be changed during "life" of the system.</p><p>This change needs to be done "synchronously", i.e. actualized at the end of system tick. It is also possible that some state 
		of system depends on transition function of sybsystem.</p><p>All these curcumstances show that it is resonable solution when system transition function is considered as state variable.</p></div><div class="sect2" title="Migration to solution"><div class="titlepage"><div><div><h3 class="title"><a name="sec_obj_as_state_intro_solution"></a>Migration to solution</h3></div></div></div><table border="0" summary="Simple list" class="simplelist"><tr><td>1.</td><td>Add special class for chromo</td></tr><tr><td>2.</td><td>Have two copies of chromo in object - new, old</td></tr></table></div><div class="sect2" title="Two approaches for chromo change: direct change and mutation"><div class="titlepage"><div><div><h3 class="title"><a name="id2952039"></a>Two approaches for chromo change: direct change and mutation</h3></div></div></div><div class="sect3" title="Mutation"><div class="titlepage"><div><div><h4 class="title"><a name="id2946175"></a>Mutation</h4></div></div></div><p>Whth this approach the system is unchangeable. The only way to change the system is to produce it's heir with mutation required
		    and then maybe kill system itself. So each change is done via new attempt of chromo.</p><p>The question here is that the system most probably updated it's state variables (it is not chromo). But it is
		    common use case when system wish to change it's sybsystem not touching the variables (for instance use case of sorting).</p><p>From this point of view the system can replace the subsystem with it's heir and move the heir to the same state as the parent was.</p><p>That looks like the parent create it's heir and gives to it all parent's variables (teached the heir).</p><p>It's OK for now. But look at the system itself. What is this change for the system? This is the change of system's structure, because
		    istead of previous subsystem it becomes new object - heir of subsystem. Thus, to be logical, we need to consider it as system's chromo
		    change that can be in turn done via regenerating the system itself. But if in turn the system is subsystem of higher level system then 
		    this means the change of system owner etc., etc.</p><p>This seems to be contradiction, but in fact it is not. That's true that if the subsystem is a part of system chromo then the whole
		    system needs to be regenerated to change the subsystem. But what if we consider system that doesn't include the "subsystem" as a part
		    of chromo, but as a state variable? For instance the community of creatures is not chromo based, it cannot be evolve with using of chromo mutation 
		    mechanism. It actually even doesn't have the chromo (really?)</p></div></div><div class="sect2" title="Use cases"><div class="titlepage"><div><div><h3 class="title"><a name="sec_obj_as_state_ucs"></a>Use cases</h3></div></div></div><div class="sect3" title="UC_OCTRL_01 Client specifies the required mutation via Object API"><div class="titlepage"><div><div><h4 class="title"><a name="uc_octrl_01"></a>UC_OCTRL_01 Client specifies the required mutation via Object API</h4></div></div></div></div><div class="sect3" title="UC_OCTRL_02 Object implies the mutation synchronously (on confirm)"><div class="titlepage"><div><div><h4 class="title"><a name="uc_octrl_02"></a>UC_OCTRL_02 Object implies the mutation synchronously (on confirm)</h4></div></div></div></div><div class="sect3" title="UC_OCTRL_03 Client can create state based on object chromo"><div class="titlepage"><div><div><h4 class="title"><a name="uc_octrl_03"></a>UC_OCTRL_03 Client can create state based on object chromo</h4></div></div></div><p>This state transition function can update object's chromo by specifying required mutation 
		    (ref <a class="xref" href="#uc_octrl_01" title="UC_OCTRL_01 Client specifies the required mutation via Object API">the section called &#8220;UC_OCTRL_01 Client specifies the required mutation via Object API&#8221;</a></p></div><div class="sect3" title="UC_OCTRL_04 Object's chromo is updated after mutation properly"><div class="titlepage"><div><div><h4 class="title"><a name="uc_octrl_04"></a>UC_OCTRL_04 Object's chromo is updated after mutation properly</h4></div></div></div></div><div class="sect3" title="UC_OCTRL_05 Object is specified via stating the parent and mutation"><div class="titlepage"><div><div><h4 class="title"><a name="uc_octrl_05"></a>UC_OCTRL_05 Object is specified via stating the parent and mutation</h4></div></div></div></div></div><div class="sect2" title="Mutation spec"><div class="titlepage"><div><div><h3 class="title"><a name="sec_obj_as_state_mutspec"></a>Mutation spec</h3></div></div></div><div class="sect3" title="Introduction"><div class="titlepage"><div><div><h4 class="title"><a name="id2958188"></a>Introduction</h4></div></div></div><p>Mutation describes the changes in object's chromo. In fact when specifying a system we never use the spec of chromo but the
		spec of mutation</p><p>There could be two approaches considered: Action based and Structure based</p></div><p>Let's consider the details of mutation spec. The spec shoutd specify the change of chromo node. Each node 
		consists of attributes and childs.</p><div class="sect3" title="Action based"><div class="titlepage"><div><div><h4 class="title"><a name="id2953953"></a>Action based</h4></div></div></div><p>Action based: specify action first then the node.  </p><pre class="programlisting">
		    &lt;remove node="some_name"\&gt;
		    &lt;add&gt; [spec of node] &lt;\add&gt;
		    &lt;change&gt; [spec of node] &lt;\change&gt;
		</pre><div class="itemizedlist" title="Actions"><p class="title"><b>Actions</b></p><ul class="itemizedlist" type="disc"><li class="listitem">Add node</li><li class="listitem">Remove node</li><li class="listitem">Change node</li></ul></div><div class="itemizedlist" title="Advantages"><p class="title"><b>Advantages</b></p><ul class="itemizedlist" type="disc"><li class="listitem"></ul></div><div class="itemizedlist" title="Disadvantages"><p class="title"><b>Disadvantages</b></p><ul class="itemizedlist" type="disc"></ul></div></div><div class="sect3" title="Structure based"><div class="titlepage"><div><div><h4 class="title"><a name="id2946828"></a>Structure based</h4></div></div></div><p> Structure based: specify node first then the action.</p><pre class="programlisting">
		    &lt;state id="some_name" mut="rm"/&gt;
		</pre><div class="itemizedlist" title="Advantages"><p class="title"><b>Advantages</b></p><ul class="itemizedlist" type="disc"><li class="listitem"></ul></div><div class="itemizedlist" title="Disadvantages"><p class="title"><b>Disadvantages</b></p><ul class="itemizedlist" type="disc"><li class="listitem">Schema are unite for all the actions. But for "remove" it is redundant to specify any node elements other than the name.</li></ul></div></div><p>Mutation spec constits of the following elements:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">Node to be changed</li><li class="listitem">Change of attribute</li><li class="listitem">Addition of child</li><li class="listitem">Deletion of child</li></ul></div></div><div class="sect2" title="Questions, issues"><div class="titlepage"><div><div><h3 class="title"><a name="sec_obj_as_state_issues"></a>Questions, issues</h3></div></div></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="id2959997"></a></h4></div></div></div></div></div></div><div class="sect1" title="Interfaces of state and object"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec_ifaces"></a>Interfaces of state and object</h2></div></div></div><p>States and objects have to represent itself by different interfaces. For instance the state should show inself as "Updatable" 
	    in its input connection point (ref <a class="xref" href="#sec_conn" title="Refs, Connections">the section called &#8220;Refs, Connections&#8221;</a>) in order that connecting state have access to Update API only.</p></div></div></body></html>
