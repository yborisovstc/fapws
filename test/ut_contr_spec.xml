<?xml version="1.0" ?>

<!-- Unit test for object's controlling -->
<!--
     There is an object "storage" that contains the "subjects" - states with the data
     Each "subject" is identified by name and contains the data 
     The states is connected in linear way. This establish the order relations for states (data)
     So the order is defined by the object (system) connections matrix
     This object is controlled "externally" by the state "orderer"
     What this state does is mutating objects connection matrix in such way that order the data
     The ordering rule (comparition) is performed by the transitions of "storage" states

     The following use cases are tested:
     1. Controlling state updates the transition matrix of object

     -->

<!DOCTYPE  caeenv SYSTEM "/home/yborisov/projects/fap/git/fapws/src/objspec.dtd"> 

<caeenv>
    <iobject type="none" id="Test">
	<mut node="self">
	    <add>
		<logspec  event="cre"> <logdata id="new"/> </logspec>

		<iobject type="none" id="Order">
		    <mut node="self">
			<add>
			    <iobject type="none" id="Storage"> 
				<mut node="self">
				    <add>
					<out id="togetup_1"/>
					<out id="togetup_2"/>
					<out id="togetup_3"/>
					
					<logspec  event="cre"> <logdata id="new"/> </logspec>

					<!-- Subject of ordering -->
					<iobject type="none" id="Subject" quiet="yes"> 
					    <mut node="self"> 
						<add>
						    <inp id="input"/>
						    <out id="output"/>
						    <out id="up"/>

						    <!-- State that contains data -->
						    <state type="StUint32" id="mass" init="0"> 
							<logspec event="cre"> <logdata id="new"/> </logspec> 
							<logspec event="upd"> <logdata id="new"/> </logspec> 
							<inp id="mass"/> 
						    </state>

						    <!-- State that forms the sign of data to be up -->
						    <state type="StBool" id="S_Up" transf="trans_up" init="0"> 
							<logspec event="cre"> <logdata id="new"/> </logspec> 
							<logspec event="upd"> <logdata id="new"/> </logspec> 
							<inp id="data"/> 
							<inp id="data_up"/> 
						    </state>

						    <conn id="S_Up.data" pair="mass.output"/> 

						    <ext id="input" pair="S_Up.data_up"/>
						    <ext id="output" pair="mass.output"/>
						    <ext id="up" pair="S_Up.output"/>
						</add> 
					    </mut>
					</iobject> <!-- Subject -->

					<iobject type="Subject" id="Peter"><mut node="mass"><change attr="init" val="5"/></mut></iobject>
					<iobject type="Subject" id="Alex"><mut node="mass"><change attr="init" val="7"/></mut></iobject>
					<iobject type="Subject" id="John"><mut node="mass"><change attr="init" val="2"/></mut></iobject>

					<conn id="Peter.output" pair="Alex.input"/> 
					<conn id="Alex.output" pair="John.input"/> 

					<!-- TODO [YB] We don't support multiple output extender. Would be convenient -->
					<ext id="togetup_1" pair="Peter.up"/>
					<ext id="togetup_2" pair="Alex.up"/>
					<ext id="togetup_3" pair="John.up"/>
				    </add>
				</mut>
			    </iobject> <!-- Storage -->

			    <!-- State that controls Storage -->
			    <state type="StUint32" id="S_Controller" transf="trans_controller" > 
				<logspec event="upd"> <logdata id="new"/> </logspec> 
				<inp id="subj_req"/> 
			    </state>

			    <conn id="S_Controller.subj_req" pair="Storage.togetup_1"/> 
			    <conn id="S_Controller.subj_req" pair="Storage.togetup_2"/> 
			    <conn id="S_Controller.subj_req" pair="Storage.togetup_3"/> 

			</add>

		    </mut>
		</iobject> <!-- Order -->

	    </add>
	</mut>
    </iobject> <!-- Test -->
</caeenv>

